<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Supervised Learning: Setting the Scene</title>
    <meta charset="utf-8" />
    <meta name="author" content="36-290 – Statistical Research Methodology" />
    <script src="Notes_05T_A-SupLearn_files/header-attrs-2.10/header-attrs.js"></script>
    <link href="Notes_05T_A-SupLearn_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="Notes_05T_A-SupLearn_files/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Supervised Learning: Setting the Scene
### 36-290 – Statistical Research Methodology
### Week 5 Tuesday – Fall 2021

---


&lt;style type="text/css"&gt;
.remark-slide-content {
    font-size: 16px;
    padding: 1em 4em 1em 4em;
}
.remark-code {
    font-size: 12px;
}
&lt;/style&gt;

&lt;style type="text/css"&gt;
table {
  font-size: 12px;
}
&lt;/style&gt;

## The Setting

The setting for *supervised learning* is that you have a collection of `\(p+1\)` measurements (recorded in columns of a data frame) for each of `\(n\)` objects (recorded in rows of a data frame). Of those measurements, `\(p\)` comprise the *predictor* (or *independent*) variables, with the last one being the *response* (or *dependent*) variable.

The goal: to model the data-generating process (i.e., to "learn a statistical model") and to discover associations between the predictor variables and the response variable. (While keeping in mind that "association is not causation.")

A statistical model is
`$$Y \vert \mathbf{x} = f(\mathbf{x}) + \epsilon \,,$$`
where `\(f(\cdot)\)` is a deterministic function that represents the expected value `\(E[Y \vert \mathbf{x}]\)` (the average observed value of `\(Y\)`, given `\(\mathbf{x} = \{x_1,\ldots,x_p\}\)`...aka "the regression line"), and `\(\epsilon\)` is an "error" that we assume is randomly sampled from some distribution, like the normal distribution. Predicted response values are given by
`$$\hat{Y}\vert \mathbf{x} = \hat{f}(\mathbf{x}) \,$$`
where the hats indicate estimated quantities.

---

## The Overarching Question: Inference...or Prediction?

*Inference*: learning a statistical model and then examining and interpreting it.

- "Adding one to the number of comorbidities leads to this amount of increased cost, on average."

*Prediction*: learning a statistical model and then treating it as a black box.

- "What is the average total insurance claim for a 60-year-old female with one intervention, no prescribed drugs, three ER visits, no complications, no comorbidities, and with a treatment duration of 100 days?"

Why does this question matter? It matters because it impacts the possible suite of models that you can apply to your dataset.

.center[
  ![:scale 70%](http://www.stat.cmu.edu/~pfreeman/infpred.png)
]

- "specified functions": functions you can write down yourself, on paper (e.g., linear regression)

- "learned functions": functions a machine learns via algorithm, given data (e.g., random forest)

---

## Inference vs. Prediction: the Tradeoff

.center[
  ![:scale 30.5%](http://www.stat.cmu.edu/~pfreeman/modeldata.png)
  ![:scale 30%](http://www.stat.cmu.edu/~pfreeman/modellinear.png)
]

As shown in the left panel, data (blue points) are generated from a smoothly varying non-linear model (black line), with random noise added. In the right panel, the red line shows a simple linear regression fit to the observed data.

The statistical model of linear regression is fully parameterized and completely inflexible. As you can see, it does not provide a good estimate of `\(f(\mathbf{x})\)`...but it has the virtue of being easy to interpret.

The basic tradeoff: the more flexible a model is, the better predictions it will generate, but the harder it will be to explain. 

**It is very important to determine, at the start of any analysis, whether the goal is inference or prediction, and if it is inference, how important inference is, and how much inferential ability you are willing to give up if predictive models provide substantially better fits to your data.**

---

## Inference vs. Prediction: Two More Important Points

- If inference is your goal, you should still always include "learned function" models like random forest in your suite of models that you will apply in an analysis.

Why? If you do not try such nonlinear models, you will never know how much better such models might perform...this information is critical. If inference is your goal, and the MSE for a random forest model is half that seen with linear regression, then you know that any inferences you draw from the latter model may not reflect reality (i.e., your inferences may be afflicted by biases: remember, inflexible models are the high-bias models, assuming that the true association is not linear).

- If prediction is your goal, you should still always include "specified function" models like linear regression in your suite of models that you will apply in an analysis.

Why? For the simple reason that the true association between the predictors and the response could be (approximately) linear. If this is the case, machine learning will not help you...and you will get the best of both worlds (inferential ability *and* predictive ability).

**In short: try all reasonable models, regardless of the analysis goal.** Then sort out the results.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
